"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeDestination = exports.CellDestination = exports.ColumnDestination = exports.RowDestination = exports.newDestination = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const ast_utils_1 = require("./ast_utils");
const column_1 = require("./column");
const range_1 = require("./range");
const row_1 = require("./row");
const lodash_1 = require("lodash");
const newDestination = (ast, table, formatter) => {
    const typeErr = ast_utils_1.checkType(ast, 'destination');
    if (typeErr) {
        return neverthrow_1.err(typeErr);
    }
    const lengthError = ast_utils_1.checkChildLength(ast, 1);
    if (lengthError) {
        return neverthrow_1.err(lengthError);
    }
    const child = ast.children[0];
    if (child.type === 'range') {
        return neverthrow_1.ok(new RangeDestination(child, table, formatter));
    }
    // must be either an absolute_reference
    try {
        switch (child.children.length) {
            case 2:
                return neverthrow_1.ok(new CellDestination(child, table, formatter));
            case 1:
                const innerChild = child.children[0];
                if (innerChild.type === 'absolute_row') {
                    return neverthrow_1.ok(new RowDestination(child, table, formatter));
                }
                else if (innerChild.type === 'absolute_column') {
                    return neverthrow_1.ok(new ColumnDestination(child, table, formatter));
                }
            default:
                return neverthrow_1.err(new Error('Unexpected destination type ' + child.type));
        }
    }
    catch (error) {
        if (error === ast_utils_1.errIndex0) {
            return neverthrow_1.err(new Error('Index 0 may not be used in a destination'));
        }
        return neverthrow_1.err(error);
    }
};
exports.newDestination = newDestination;
class RowDestination {
    constructor(ast, table, formatter) {
        this.merge = (source, table) => {
            // for cell in row...
            const cells = lodash_1.range(0, table.getWidth()).map((columnNum) => ({ row: this.row.index, column: columnNum }));
            return mergeForCells(source, table, cells, this.formatter);
        };
        this.formatter = formatter;
        const typeErr = ast_utils_1.checkType(ast, 'absolute_reference');
        if (typeErr) {
            throw typeErr;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 1);
        if (lengthError) {
            throw lengthError;
        }
        const child = ast.children[0];
        try {
            this.row = new row_1.AbsoluteRow(child, table);
        }
        catch (error) {
            // In a constructor, so we must throw
            throw error;
        }
    }
}
exports.RowDestination = RowDestination;
class ColumnDestination {
    constructor(ast, table, formatter) {
        this.merge = (source, table) => {
            // for cell in column (excluding header)...
            const cells = lodash_1.range(2, table.getHeight()).map((rowNum) => ({ row: rowNum, column: this.column.index }));
            return mergeForCells(source, table, cells, this.formatter);
        };
        this.formatter = formatter;
        const typeErr = ast_utils_1.checkType(ast, 'absolute_reference');
        if (typeErr) {
            throw typeErr;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 1);
        if (lengthError) {
            throw lengthError;
        }
        const child = ast.children[0];
        try {
            this.column = new column_1.AbsoluteColumn(child, table);
        }
        catch (error) {
            // In a constructor, so we must throw
            throw error;
        }
    }
}
exports.ColumnDestination = ColumnDestination;
class CellDestination {
    constructor(ast, table, formatter) {
        this.merge = (source, table) => {
            const cell = { row: this.row.index, column: this.column.index };
            return mergeForCells(source, table, [cell], this.formatter);
        };
        this.formatter = formatter;
        const typeErr = ast_utils_1.checkType(ast, 'absolute_reference');
        if (typeErr) {
            throw typeErr;
        }
        // A cell needs to have two children, a row and a column
        const lengthError = ast_utils_1.checkChildLength(ast, 2);
        if (lengthError) {
            throw lengthError;
        }
        const rowChild = ast.children[0];
        const colChild = ast.children[1];
        try {
            this.row = new row_1.AbsoluteRow(rowChild, table);
            this.column = new column_1.AbsoluteColumn(colChild, table);
        }
        catch (error) {
            // In a constructor, so we must throw
            throw error;
        }
    }
}
exports.CellDestination = CellDestination;
class RangeDestination {
    constructor(ast, table, formatter) {
        this.merge = (source, table) => this.range
            .asCells()
            .andThen((cells) => mergeForCells(source, table, cells, this.formatter));
        this.formatter = formatter;
        const typeErr = ast_utils_1.checkType(ast, 'range');
        if (typeErr) {
            throw typeErr;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 2);
        if (lengthError) {
            throw lengthError;
        }
        ast.children.forEach((child) => {
            let childTypeErr = ast_utils_1.checkType(child, 'source_reference');
            if (childTypeErr) {
                throw childTypeErr;
            }
            const childLengthError = ast_utils_1.checkChildLength(child, 1);
            if (childLengthError) {
                throw childLengthError;
            }
            childTypeErr = ast_utils_1.checkType(child.children[0], 'absolute_reference');
            if (childTypeErr) {
                throw childTypeErr;
            }
        });
        this.range = new range_1.Range(ast, table);
    }
}
exports.RangeDestination = RangeDestination;
const mergeForCells = (source, table, cells, formatter) => cells.reduce((currentTable, currentCell) => currentTable.andThen((t) => source
    .getValue(t, currentCell)
    .andThen((val) => neverthrow_1.ok(val.toString()))
    .andThen((val) => neverthrow_1.ok(val.trim() === '' ? '0' : val))
    .andThen((val) => neverthrow_1.ok(t.setCellAt(currentCell.row, currentCell.column, formatter.format(val))))), neverthrow_1.ok(table));
