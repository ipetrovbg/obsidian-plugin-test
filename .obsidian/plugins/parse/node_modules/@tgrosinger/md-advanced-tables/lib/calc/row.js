"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsoluteRow = exports.Row = exports.newRow = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const ast_utils_1 = require("./ast_utils");
const results_1 = require("./results");
const newRow = (ast, table) => {
    try {
        switch (ast.type) {
            case 'relative_row':
                return neverthrow_1.ok(new RelativeRow(ast, table));
            case 'absolute_row':
                return neverthrow_1.ok(new AbsoluteRow(ast, table));
            default:
                return neverthrow_1.err(new Error(`Formula element '${ast.text}' is a ${ast.type} but expected an ` +
                    'relatve_row or absolute_row  in this position.'));
        }
    }
    catch (error) {
        return neverthrow_1.err(error);
    }
};
exports.newRow = newRow;
class Row {
    constructor() {
        this.getValue = (table, currentCell) => {
            var _a;
            const val = ((_a = table
                .getCellAt(this.getIndex(currentCell), currentCell.column)) === null || _a === void 0 ? void 0 : _a.toText()) || '';
            return neverthrow_1.ok(new results_1.Value([[val]]));
        };
    }
}
exports.Row = Row;
class RelativeRow extends Row {
    constructor(ast, table) {
        super();
        this.getIndex = (currentCell) => currentCell.row + this.offset;
        this.getAbsoluteIndex = () => neverthrow_1.err(ast_utils_1.errRelativeReferenceIndex);
        const typeError = ast_utils_1.checkType(ast, 'relative_row');
        if (typeError) {
            throw typeError;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 1);
        if (lengthError) {
            throw lengthError;
        }
        const multiplier = ast.text[1] === '-' ? -1 : 1;
        this.offset = multiplier * parseInt(ast.children[0].text);
    }
}
class AbsoluteRow extends Row {
    constructor(ast, table) {
        super();
        this.getIndex = (currentCell) => this.index;
        this.getAbsoluteIndex = () => neverthrow_1.ok(this.index);
        let index = -1;
        let symbol = '';
        switch (ast.children.length) {
            case 0:
                symbol = ast.text[1];
                break;
            case 1:
                const typeError = ast_utils_1.checkType(ast.children[0], 'int');
                if (typeError) {
                    throw neverthrow_1.err(typeError);
                }
                index = parseInt(ast.children[0].text);
                break;
            default:
                throw new Error(`Formula element '${ast.text}' is a ${ast.type} but expected ` +
                    'a \'absolute_row\' in this position.');
        }
        switch (symbol) {
            case '':
                break;
            case '<':
                index = 1;
                break;
            case '>':
                index = table.getHeight() - 1;
                break;
            case 'I':
                index = 2;
                break;
            default:
                throw new Error(`Invalid row symbol '${symbol}'`);
        }
        if (index === 0) {
            throw ast_utils_1.errIndex0;
        }
        if (index === 1) {
            this.index = 0; // account for being zero indexed
        }
        else {
            this.index = index; // -1 for being zero indexed, but plus 1 to skip header
        }
    }
}
exports.AbsoluteRow = AbsoluteRow;
