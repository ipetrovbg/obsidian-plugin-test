"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reference = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const ast_utils_1 = require("./ast_utils");
const column_1 = require("./column");
const results_1 = require("./results");
const row_1 = require("./row");
class Reference {
    constructor(ast, table) {
        this.getValue = (table, currentCell) => {
            var _a;
            const cell = {
                row: this.row ? this.row.getIndex(currentCell) : currentCell.row,
                column: this.column
                    ? this.column.getIndex(currentCell)
                    : currentCell.column,
            };
            const val = ((_a = table.getCellAt(cell.row, cell.column)) === null || _a === void 0 ? void 0 : _a.toText()) || '';
            return neverthrow_1.ok(new results_1.Value([[val]]));
        };
        const typeErr = ast_utils_1.checkType(ast, 'source_reference', 'absolute_reference', 'relative_reference');
        if (typeErr) {
            throw typeErr;
        }
        for (let i = 0; i < ast.children.length; i++) {
            const child = ast.children[i];
            switch (child.type) {
                case 'relative_row':
                case 'absolute_row':
                    if (this.row !== undefined) {
                        throw Error('Reference may only have at most 1 row, more than 1 provided');
                    }
                    const createdRow = row_1.newRow(child, table);
                    if (createdRow.isErr()) {
                        if (createdRow.error === ast_utils_1.errIndex0) {
                            // not actually an error, just indicates using current index
                            break;
                        }
                        throw createdRow.error;
                    }
                    this.row = createdRow.value;
                    break;
                case 'relative_column':
                case 'absolute_column':
                    if (this.column !== undefined) {
                        throw Error('Reference may only have at most 1 column, more than 1 provided');
                    }
                    const createdCol = column_1.newColumn(child, table);
                    if (createdCol.isErr()) {
                        if (createdCol.error === ast_utils_1.errIndex0) {
                            // not actually an error, just indicates using current index
                            break;
                        }
                        throw createdCol.error;
                    }
                    this.column = createdCol.value;
                    break;
            }
        }
    }
}
exports.Reference = Reference;
