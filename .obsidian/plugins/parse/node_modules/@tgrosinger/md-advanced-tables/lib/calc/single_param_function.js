"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SingleParamFunctionCall = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const ast_utils_1 = require("./ast_utils");
const calc_1 = require("./calc");
const results_1 = require("./results");
class SingleParamFunctionCall {
    constructor(ast, table) {
        this.getValue = (table, cell) => this.param.getValue(table, cell).andThen((sourceData) => 
        // The operation functions do not throw errors because data arity has
        // already been validated.
        neverthrow_1.ok(this.op(sourceData)));
        const typeError = ast_utils_1.checkType(ast, 'single_param_function_call');
        if (typeError) {
            throw typeError;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 2);
        if (lengthError) {
            throw lengthError;
        }
        const childTypeError = ast_utils_1.checkType(ast.children[0], 'single_param_function');
        if (childTypeError) {
            throw childTypeError;
        }
        const functionName = ast.children[0].text;
        switch (functionName) {
            case 'sum':
                this.op = sum;
                break;
            case 'mean':
                this.op = mean;
                break;
            default:
                throw Error('Unknown single param function call: ' + functionName);
        }
        this.param = new calc_1.Source(ast.children[1], table);
    }
}
exports.SingleParamFunctionCall = SingleParamFunctionCall;
/**
 * Sum all the cells in the input value, producing a single cell output.
 */
const sum = (value) => {
    const total = value.val.reduce((runningTotal, currentRow) => currentRow.reduce((rowTotal, currentCell) => {
        let currentCellValue = parseFloat(currentCell);
        if (isNaN(currentCellValue)) {
            currentCellValue = 0;
        }
        return rowTotal + currentCellValue;
    }, runningTotal), 0);
    return new results_1.Value([[total.toString()]]);
};
/**
 * Mean of all the cells in the input value, producing a single cell output.
 */
const mean = (value) => {
    const { total, count } = value.val.reduce(({ total: runningTotal1, count: currentCount1 }, currentRow) => currentRow.reduce(({ total: runningTotal2, count: currentCount2 }, currentCell) => ({
        total: runningTotal2 + +currentCell,
        count: currentCount2 + 1,
    }), { total: runningTotal1, count: currentCount1 }), { total: 0, count: 0 });
    return new results_1.Value([[(total / count).toString()]]);
};
