"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFormula = exports.parseAndApply = exports.Source = exports.Formula = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const algebraic_operation_1 = require("./algebraic_operation");
const ast_utils_1 = require("./ast_utils");
const conditional_function_1 = require("./conditional_function");
const constant_1 = require("./constant");
const destination_1 = require("./destination");
const display_directive_1 = require("./display_directive");
const range_1 = require("./range");
const reference_1 = require("./reference");
const single_param_function_1 = require("./single_param_function");
const ebnf_1 = require("ebnf");
const lodash_1 = require("lodash");
/**
 * W3C grammar describing a valid formula at the bottom of a table.
 *
 * The library being used to parse the formula does not suport EBNF, only BNF,
 * so W3C syntax was used in order to get access to extended features.
 *
 * The parser generates a PEG parser, whic is not able to handle ambiguity. The
 * order of constructions is significant.
 * See https://github.com/lys-lang/node-ebnf/issues/34
 */
const parserGrammar = `
tblfm_line   ::= "<!-- TBLFM: " formula_list " -->"
formula_list ::= formula ( "::" formula_list )?
formula      ::= destination "=" source display_directive?

source           ::= range | source_reference | single_param_function_call | conditional_function_call | algebraic_operation | real
range            ::= source_reference ".." source_reference
source_reference ::= absolute_reference | relative_reference
destination      ::= range | absolute_reference

relative_reference ::= (relative_row | absolute_row) (relative_column | absolute_column) | relative_row | relative_column
relative_row ::= "@" ( "-" | "+" ) int
relative_column ::= "$" ( "-" | "+" ) int

absolute_reference ::= absolute_row absolute_column | absolute_row | absolute_column
absolute_row ::= "@" ( "I" | "<" | ">" | int )
absolute_column ::= "$" ( "<" | ">" | int )

single_param_function_call ::= single_param_function "(" source ")" 
single_param_function      ::= "mean" | "sum"

conditional_function_call ::= "if(" predicate "," " "? source "," " "? source ")"
predicate                 ::= source_without_range conditional_operator source_without_range
source_without_range      ::= source_reference | single_param_function_call | conditional_function_call | algebraic_operation | real
conditional_operator      ::= ">" | "<" | ">=" | "<=" | "==" | "!="

algebraic_operation ::= "(" source " "? algebraic_operator " "? source ")"
algebraic_operator  ::= "+" | "-" | "*" | "/"

display_directive        ::= ";" display_directive_option
display_directive_option ::= formatting_directive
formatting_directive     ::= "%." int "f"

real ::= "-"? int
int  ::= [0-9]+
`;
class Formula {
    constructor(ast, table) {
        this.merge = (table) => this.destination.merge(this.source, table);
        let formatter = new display_directive_1.DefaultFormatter();
        if (ast.children.length === 3) {
            formatter = new display_directive_1.DisplayDirective(ast.children[2]);
        }
        const destination = destination_1.newDestination(ast.children[0], table, formatter);
        if (destination.isErr()) {
            throw destination.error;
        }
        this.destination = destination.value;
        this.source = new Source(ast.children[1], table);
    }
}
exports.Formula = Formula;
class Source {
    constructor(ast, table) {
        /**
         * getValue returns the evaluated value for this source recursively.
         */
        this.getValue = (table, currentCell) => this.locationDescriptor.getValue(table, currentCell);
        if (ast.type !== 'source' && ast.type !== 'source_without_range') {
            throw Error('Invalid AST token type of ' + ast.type);
        }
        if (ast.children.length !== 1) {
            throw Error('Unexpected children length in Source');
        }
        const paramChild = ast.children[0];
        const vp = newValueProvider(paramChild, table);
        if (vp.isErr()) {
            throw vp.error;
        }
        this.locationDescriptor = vp.value;
    }
}
exports.Source = Source;
const newValueProvider = (ast, table) => {
    try {
        switch (ast.type) {
            case 'range':
                return neverthrow_1.ok(new range_1.Range(ast, table));
            case 'source_reference':
                const lengthError = ast_utils_1.checkChildLength(ast, 1);
                if (lengthError) {
                    return neverthrow_1.err(lengthError);
                }
                return neverthrow_1.ok(new reference_1.Reference(ast.children[0], table));
            case 'single_param_function_call':
                return neverthrow_1.ok(new single_param_function_1.SingleParamFunctionCall(ast, table));
            case 'conditional_function_call':
                return neverthrow_1.ok(new conditional_function_1.ConditionalFunctionCall(ast, table));
            case 'algebraic_operation':
                return neverthrow_1.ok(new algebraic_operation_1.AlgebraicOperation(ast, table));
            case 'real':
                return neverthrow_1.ok(new constant_1.Constant(ast, table));
            default:
                throw Error('Unrecognized valueProvider type ' + ast.type);
        }
    }
    catch (error) {
        return neverthrow_1.err(error);
    }
};
const parseAndApply = (formulaLines, table) => {
    // Parse each formula line, flattening the resulting lists of formulas into a
    // single list, but returning an error if any formula fails to parse.
    const formulas = formulaLines.reduce((prev, formulaLine) => prev.andThen((currentFormulas) => {
        const newFormulas = exports.parseFormula(formulaLine, table);
        if (newFormulas.isErr()) {
            return newFormulas;
        }
        return neverthrow_1.ok(lodash_1.concat(newFormulas.value, currentFormulas));
    }), neverthrow_1.ok([]));
    // If there is no error,
    return formulas.andThen((innerFormulas) => 
    // for each formula
    innerFormulas.reduce((prevValue, formula) => 
    // If the previous formula didn't give an error
    prevValue.andThen((prevTable) => 
    // attempt to apply this formula to the table and return the result
    formula.merge(prevTable)), 
    // Start with the current table state
    neverthrow_1.ok(table)));
};
exports.parseAndApply = parseAndApply;
/**
 * Parse the provided line, returning any found formulas. A single line may
 * contain zero or more formulas.
 *
 * @param line A line of the form `<!-- TBFM: {FORMULA}::{FORMULA} -->`
 */
const parseFormula = (line, table) => {
    const parser = new ebnf_1.Grammars.W3C.Parser(parserGrammar);
    const ast = parser.getAST(line);
    // TODO: Determine how to return errors when a formula-like string
    //       is not actually a valid formula.
    if (!ast) {
        return neverthrow_1.err(new Error(`Formula '${line}' could not be parsed`));
    }
    const typeError = ast_utils_1.checkType(ast, 'tblfm_line');
    if (typeError) {
        return neverthrow_1.err(typeError);
    }
    const lengthError = ast_utils_1.checkChildLength(ast, 1);
    if (lengthError) {
        return neverthrow_1.err(lengthError);
    }
    const formulas = ast.children[0].children;
    try {
        return neverthrow_1.ok(formulas.map((formula) => new Formula(formula, table)));
    }
    catch (error) {
        return neverthrow_1.err(error);
    }
};
exports.parseFormula = parseFormula;
