"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConditionalFunctionCall = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const ast_utils_1 = require("./ast_utils");
const calc_1 = require("./calc");
class ConditionalFunctionCall {
    constructor(ast, table) {
        this.getValue = (table, cell) => this.predicate
            .eval(table, cell)
            .andThen((predicateResult) => predicateResult
            ? this.leftSource.getValue(table, cell)
            : this.rightSource.getValue(table, cell));
        const typeError = ast_utils_1.checkType(ast, 'conditional_function_call');
        if (typeError) {
            throw typeError;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 3);
        if (lengthError) {
            throw lengthError;
        }
        try {
            this.predicate = new Predicate(ast.children[0], table);
            this.leftSource = new calc_1.Source(ast.children[1], table);
            this.rightSource = new calc_1.Source(ast.children[2], table);
        }
        catch (error) {
            // Still in a constructor, so nothing we can do but throw again
            throw error;
        }
    }
}
exports.ConditionalFunctionCall = ConditionalFunctionCall;
class Predicate {
    constructor(ast, table) {
        this.eval = (table, cell) => {
            const leftData = this.leftSource.getValue(table, cell);
            if (leftData.isErr()) {
                return neverthrow_1.err(leftData.error);
            }
            const rightData = this.rightSource.getValue(table, cell);
            if (rightData.isErr()) {
                return neverthrow_1.err(rightData.error);
            }
            const leftArity = leftData.value.getArity();
            const rightArity = rightData.value.getArity();
            if (!leftArity.isCell()) {
                return neverthrow_1.err(Error('Can only use comparison operator on a single cell. Left side is not a cell.'));
            }
            if (!rightArity.isCell()) {
                return neverthrow_1.err(Error('Can only use comparison operator on a single cell. Right side is not a cell.'));
            }
            const leftVal = leftData.value.getAsFloat(0, 0);
            const rightVal = rightData.value.getAsFloat(0, 0);
            switch (this.operator) {
                case '>':
                    return neverthrow_1.ok(leftVal > rightVal);
                case '>=':
                    return neverthrow_1.ok(leftVal >= rightVal);
                case '<':
                    return neverthrow_1.ok(leftVal < rightVal);
                case '<=':
                    return neverthrow_1.ok(leftVal <= rightVal);
                case '==':
                    return neverthrow_1.ok(leftVal === rightVal);
                case '!=':
                    return neverthrow_1.ok(leftVal !== rightVal);
                default:
                    return neverthrow_1.err(Error('Invalid conditional operator: ' + this.operator));
            }
        };
        const typeError = ast_utils_1.checkType(ast, 'predicate');
        if (typeError) {
            throw typeError;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 3);
        if (lengthError) {
            throw lengthError;
        }
        const childTypeError = ast_utils_1.checkType(ast.children[1], 'conditional_operator');
        if (childTypeError) {
            throw childTypeError;
        }
        this.operator = ast.children[1].text;
        try {
            this.leftSource = new calc_1.Source(ast.children[0], table);
            this.rightSource = new calc_1.Source(ast.children[2], table);
        }
        catch (error) {
            // Still in a constructor, so nothing we can do but throw again
            throw error;
        }
    }
}
