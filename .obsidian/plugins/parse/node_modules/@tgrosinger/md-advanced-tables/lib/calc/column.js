"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsoluteColumn = exports.Column = exports.newColumn = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const ast_utils_1 = require("./ast_utils");
const results_1 = require("./results");
const newColumn = (ast, table) => {
    try {
        switch (ast.type) {
            case 'relative_column':
                return neverthrow_1.ok(new RelativeColumn(ast, table));
            case 'absolute_column':
                return neverthrow_1.ok(new AbsoluteColumn(ast, table));
            default:
                return neverthrow_1.err(new Error(`Formula element '${ast.text}' is a ${ast.type} but expected an ` +
                    'relatve_column or absolute_column in this position.'));
        }
    }
    catch (error) {
        return neverthrow_1.err(error);
    }
};
exports.newColumn = newColumn;
class Column {
    constructor() {
        this.getValue = (table, currentCell) => {
            var _a;
            const val = ((_a = table.getCellAt(currentCell.row, this.getIndex(currentCell))) === null || _a === void 0 ? void 0 : _a.toText()) ||
                '';
            return neverthrow_1.ok(new results_1.Value([[val]]));
        };
    }
}
exports.Column = Column;
class RelativeColumn extends Column {
    constructor(ast, table) {
        super();
        this.getIndex = (currentCell) => currentCell.column + this.offset;
        this.getAbsoluteIndex = () => neverthrow_1.err(ast_utils_1.errRelativeReferenceIndex);
        const typeError = ast_utils_1.checkType(ast, 'relative_column');
        if (typeError) {
            throw typeError;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 1);
        if (lengthError) {
            throw lengthError;
        }
        const multiplier = ast.text[1] === '-' ? -1 : 1;
        this.offset = multiplier * parseInt(ast.children[0].text);
    }
}
class AbsoluteColumn extends Column {
    constructor(ast, table) {
        super();
        this.getIndex = (currentCell) => this.index;
        this.getAbsoluteIndex = () => neverthrow_1.ok(this.index);
        let index = -1;
        let symbol = '';
        switch (ast.children.length) {
            case 0:
                symbol = ast.text[1];
                break;
            case 1:
                const typeError = ast_utils_1.checkType(ast.children[0], 'int');
                if (typeError) {
                    throw neverthrow_1.err(typeError);
                }
                index = parseInt(ast.children[0].text);
                break;
            default:
                throw new Error(`Formula element '${ast.text}' is a ${ast.type} but expected ` +
                    'a \'absolute_column\' in this position.');
        }
        switch (symbol) {
            case '':
                break;
            case '<':
                index = 1;
                break;
            case '>':
                index = table.getWidth();
                break;
            default:
                throw new Error(`Invalid column symbol '${symbol}'`);
        }
        if (index === 0) {
            throw ast_utils_1.errIndex0;
        }
        this.index = index - 1; // -1 for being zero indexed
    }
}
exports.AbsoluteColumn = AbsoluteColumn;
