"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlgebraicOperation = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const ast_utils_1 = require("./ast_utils");
const calc_1 = require("./calc");
const results_1 = require("./results");
const lodash_1 = require("lodash");
class AlgebraicOperation {
    constructor(ast, table) {
        this.getValue = (table, cell) => {
            switch (this.operator) {
                case '+':
                    return this.add(table, cell);
                case '-':
                    return this.subtract(table, cell);
                case '*':
                    return this.multiply(table, cell);
                case '/':
                    return this.divide(table, cell);
                default:
                    return neverthrow_1.err(Error('Invalid algbraic operator: ' + this.operator));
            }
        };
        /**
         * withCellAndRange aids in performing a numeric operation on cells in a
         * table where at least one of the two operands is a single cell. Optionally,
         * the two sides of the operation can be swapped, so the single cell is
         * always on the right.
         */
        this.withCellAndRange = (table, cell, name, canHaveRightRange, fn) => {
            const leftValue = this.leftSource.getValue(table, cell);
            if (leftValue.isErr()) {
                return neverthrow_1.err(leftValue.error);
            }
            const rightValue = this.rightSource.getValue(table, cell);
            if (rightValue.isErr()) {
                return neverthrow_1.err(rightValue.error);
            }
            const leftArity = leftValue.value.getArity();
            const rightArity = rightValue.value.getArity();
            if (!rightArity.isCell() && !leftArity.isCell()) {
                return neverthrow_1.err(Error(`At least one operand in algebraic "${name}" must be a single cell.`));
            }
            if (!rightArity.isCell() && !canHaveRightRange) {
                return neverthrow_1.err(Error(`Right operand in algebraic "${name}" must be a single cell.`));
            }
            if (rightArity.isCell()) {
                const rightCellValue = rightValue.value.getAsFloat(0, 0);
                const result = lodash_1.map(leftValue.value.val, (currentRow) => lodash_1.map(currentRow, (currentCell) => {
                    let leftCellValue = parseFloat(currentCell);
                    if (isNaN(leftCellValue)) {
                        leftCellValue = 0;
                    }
                    return fn(leftCellValue, rightCellValue).toString();
                }));
                return neverthrow_1.ok(new results_1.Value(result));
            }
            const leftCellValue = leftValue.value.getAsFloat(0, 0);
            const result = lodash_1.map(rightValue.value.val, (currentRow) => lodash_1.map(currentRow, (currentCell) => {
                let rightCellValue = parseFloat(currentCell);
                if (isNaN(leftCellValue)) {
                    rightCellValue = 0;
                }
                return fn(leftCellValue, rightCellValue).toString();
            }));
            return neverthrow_1.ok(new results_1.Value(result));
        };
        this.add = (table, cell) => this.withCellAndRange(table, cell, 'add', true, (left, right) => left + right);
        this.subtract = (table, cell) => this.withCellAndRange(table, cell, 'subtract', true, (left, right) => left - right);
        this.multiply = (table, cell) => this.withCellAndRange(table, cell, 'multiply', true, (left, right) => left * right);
        this.divide = (table, cell) => this.withCellAndRange(table, cell, 'divide', false, (left, right) => left / right);
        const typeErr = ast_utils_1.checkType(ast, 'algebraic_operation');
        if (typeErr) {
            throw typeErr;
        }
        const lengthError = ast_utils_1.checkChildLength(ast, 3);
        if (lengthError) {
            throw lengthError;
        }
        const childTypeErr = ast_utils_1.checkType(ast.children[1], 'algebraic_operator');
        if (childTypeErr) {
            throw childTypeErr;
        }
        this.operator = ast.children[1].text;
        try {
            this.leftSource = new calc_1.Source(ast.children[0], table);
            this.rightSource = new calc_1.Source(ast.children[2], table);
        }
        catch (error) {
            // Still in a constructor, so nothing we can do but throw again
            throw error;
        }
    }
}
exports.AlgebraicOperation = AlgebraicOperation;
