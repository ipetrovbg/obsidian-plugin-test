"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Range = void 0;
const neverthrow_1 = require("../neverthrow/neverthrow");
const ast_utils_1 = require("./ast_utils");
const reference_1 = require("./reference");
const results_1 = require("./results");
const lodash_1 = require("lodash");
class Range {
    constructor(ast, table) {
        this.getValue = (table, currentCell) => {
            // if no start column is provided, copy it from the currentCell
            const startColumn = this.startColumn
                ? this.startColumn.getIndex(currentCell)
                : currentCell.column;
            // if the column is provided in the first set, but not the second, copy it
            const endColumn = this.endColumn
                ? this.endColumn.getIndex(currentCell)
                : startColumn;
            const startRow = this.startRow
                ? this.startRow.getIndex(currentCell)
                : currentCell.row;
            const endRow = this.endRow
                ? this.endRow.getIndex(currentCell)
                : currentCell.row;
            return neverthrow_1.ok(new results_1.Value(lodash_1.map(lodash_1.range(startRow, endRow + 1), (row) => lodash_1.map(lodash_1.range(startColumn, endColumn + 1), (col) => { var _a; return ((_a = table.getCellAt(row, col)) === null || _a === void 0 ? void 0 : _a.toText()) || ''; }))));
        };
        // There needs to be a distinction between ranges for source and destination
        // a destination range does not allow relative references, which would
        // solve this issue with getting the index.
        this.asCells = () => {
            if (!this.startColumn || !this.startRow || !this.endRow) {
                return neverthrow_1.err(new Error('A range used as a desintation must define rows and cells'));
            }
            // If the second reference in the range does not include a column,
            // use the start column.
            let endColumn = this.endColumn;
            if (!endColumn) {
                endColumn = this.startColumn;
            }
            const startRowIndex = this.startRow.getAbsoluteIndex();
            const endRowIndex = this.endRow.getAbsoluteIndex();
            const startColumnIndex = this.startColumn.getAbsoluteIndex();
            const endColumnIndex = endColumn.getAbsoluteIndex();
            if (startRowIndex.isErr() ||
                endRowIndex.isErr() ||
                startColumnIndex.isErr() ||
                endColumnIndex.isErr()) {
                return neverthrow_1.err(new Error('A relative range can not be used in a formula destination'));
            }
            const minRow = Math.min(startRowIndex.value, endRowIndex.value);
            const maxRow = Math.max(startRowIndex.value, endRowIndex.value);
            const minColumn = Math.min(startColumnIndex.value, endColumnIndex.value);
            const maxColumn = Math.max(startColumnIndex.value, endColumnIndex.value);
            return neverthrow_1.ok(lodash_1.flatMap(lodash_1.range(minRow, maxRow + 1), (rowNum) => lodash_1.range(minColumn, maxColumn + 1).map((colNum) => ({ row: rowNum, column: colNum }))));
        };
        let typeErr = ast_utils_1.checkType(ast, 'range');
        if (typeErr) {
            throw typeErr;
        }
        let lengthError = ast_utils_1.checkChildLength(ast, 2);
        if (lengthError) {
            throw lengthError;
        }
        const startChild = ast.children[0];
        const endChild = ast.children[1];
        typeErr = ast_utils_1.checkType(startChild, 'source_reference');
        if (typeErr) {
            throw typeErr;
        }
        typeErr = ast_utils_1.checkType(endChild, 'source_reference');
        if (typeErr) {
            throw typeErr;
        }
        lengthError = ast_utils_1.checkChildLength(startChild, 1);
        if (lengthError) {
            throw lengthError;
        }
        lengthError = ast_utils_1.checkChildLength(endChild, 1);
        if (lengthError) {
            throw lengthError;
        }
        const start = new reference_1.Reference(startChild.children[0], table);
        const end = new reference_1.Reference(endChild.children[0], table);
        if ((start.row && !end.row) || (end.row && !start.row)) {
            throw new Error('Range must use references of the same kind');
        }
        // Must provide at least a row or a column, but if the first value has a
        // column but the second does not, then copy the first col to second.
        if (!start.row && !start.column) {
            console.log(start);
            throw new Error('Range must have a row or a column defined');
        }
        if (start.row) {
            this.startRow = start.row;
        }
        if (start.column) {
            this.startColumn = start.column;
        }
        if (end.row) {
            this.endRow = end.row;
        }
        if (end.column) {
            this.endColumn = end.column;
        }
        else {
            this.endColumn = start.column;
        }
    }
}
exports.Range = Range;
