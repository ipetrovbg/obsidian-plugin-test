"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readTable = exports._marginRegex = exports.marginRegexSrc = exports._readRow = exports._splitCells = void 0;
const table_1 = require("./table");
const table_cell_1 = require("./table-cell");
const table_row_1 = require("./table-row");
/**
 * Splits a text into cells.
 *
 * @private
 */
const _splitCells = (text) => {
    const cells = [];
    let buf = '';
    let rest = text;
    while (rest !== '') {
        switch (rest[0]) {
            case '`':
                // read code span
                {
                    const startMatch = rest.match(/^`*/);
                    if (startMatch === null) {
                        // case statement ensures first char is a ` and we cannot get here.
                        // This just satisfies the compiler.
                        break;
                    }
                    const start = startMatch[0];
                    let buf1 = start;
                    let rest1 = rest.substr(start.length);
                    let closed = false;
                    while (rest1 !== '') {
                        if (rest1[0] === '`') {
                            const endMatch = rest1.match(/^`*/);
                            if (endMatch === null) {
                                // case statement ensures first char is a ` and we cannot get here.
                                // This just satisfies the compiler.
                                break;
                            }
                            const end = endMatch[0];
                            buf1 += end;
                            rest1 = rest1.substr(end.length);
                            if (end.length === start.length) {
                                closed = true;
                                break;
                            }
                        }
                        else {
                            buf1 += rest1[0];
                            rest1 = rest1.substr(1);
                        }
                    }
                    if (closed) {
                        buf += buf1;
                        rest = rest1;
                    }
                    else {
                        buf += '`';
                        rest = rest.substr(1);
                    }
                }
                break;
            case '\\':
                // escape next character
                if (rest.length >= 2) {
                    buf += rest.substr(0, 2);
                    rest = rest.substr(2);
                }
                else {
                    buf += '\\';
                    rest = rest.substr(1);
                }
                break;
            case '|':
                // flush buffer
                cells.push(buf);
                buf = '';
                rest = rest.substr(1);
                break;
            default:
                buf += rest[0];
                rest = rest.substr(1);
        }
    }
    cells.push(buf);
    return cells;
};
exports._splitCells = _splitCells;
/**
 * Reads a table row.
 *
 * @private
 * @param text - A text.
 * @param [leftMarginRegex=/^\s*$/] - A regular expression object that matches left margin.
 */
const _readRow = (text, leftMarginRegex = /^\s*$/) => {
    let cells = exports._splitCells(text);
    let marginLeft;
    if (cells.length > 0 && leftMarginRegex.test(cells[0])) {
        marginLeft = cells[0];
        cells = cells.slice(1);
    }
    else {
        marginLeft = '';
    }
    let marginRight;
    if (cells.length > 1 && /^\s*$/.test(cells[cells.length - 1])) {
        marginRight = cells[cells.length - 1];
        cells = cells.slice(0, cells.length - 1);
    }
    else {
        marginRight = '';
    }
    return new table_row_1.TableRow(cells.map((cell) => new table_cell_1.TableCell(cell)), marginLeft, marginRight);
};
exports._readRow = _readRow;
/**
 * Creates a regex source string of margin character class.
 *
 * @private
 * @param chars - A set of additional margin characters.
 * A pipe `|`, a backslash `\`, and a backquote will be ignored.
 * @return A regex source string.
 */
const marginRegexSrc = (chars) => {
    let cs = '';
    // for (const c chars.values()) {
    chars.forEach((c) => {
        if (c !== '|' && c !== '\\' && c !== '`') {
            cs += `\\u{${c.codePointAt(0).toString(16)}}`;
        }
    });
    return `[\\s${cs}]*`;
};
exports.marginRegexSrc = marginRegexSrc;
/**
 * Creates a regular expression object that matches margin of tables.
 *
 * @private
 * @param chars - A set of additional margin characters.
 * A pipe `|`, a backslash `\`, and a backquote will be ignored.
 * @return An regular expression object that matches margin of tables.
 */
const _marginRegex = (chars) => new RegExp(`^${exports.marginRegexSrc(chars)}$`, 'u');
exports._marginRegex = _marginRegex;
/**
 * Reads a table from lines.
 *
 * @private
 * @param lines - An array of texts, each text represents a row.
 * @param options - An object containing options for parsing.
 * @returns The table read from the lines.
 */
const readTable = (lines, options) => {
    const leftMarginRegex = exports._marginRegex(options.leftMarginChars);
    return new table_1.Table(lines.map((line) => exports._readRow(line, leftMarginRegex)));
};
exports.readTable = readTable;
