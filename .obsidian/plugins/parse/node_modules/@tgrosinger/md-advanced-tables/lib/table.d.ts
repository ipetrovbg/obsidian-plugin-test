import { Focus } from './focus';
import { Result } from './neverthrow/neverthrow';
import { Point } from './point';
import { Range } from './range';
import { TableCell } from './table-cell';
import { TableRow } from './table-row';
/**
 * A `Table` object represents a table.
 *
 * @private
 */
export declare class Table {
    private readonly _rows;
    /**
     * Creates a new `Table` object.
     *
     * @param rows - An array of rows that the table contains.
     * @param formulas - An array of formulas attached to the table.
     */
    constructor(rows: TableRow[]);
    /**
     * Gets the number of rows in the table.
     *
     * @returns The number of rows.
     */
    getHeight(): number;
    /**
     * Gets the maximum width of the rows in the table.
     *
     * @returns The maximum width of the rows.
     */
    getWidth(): number;
    /**
     * Gets the width of the header row.
     * Assumes that it is called on a valid table with a header row.
     *
     * @returns The width of the header row
     */
    getHeaderWidth(): number;
    /**
     * Gets the rows that the table contains.
     *
     * @returns An array of the rows.
     */
    getRows(): TableRow[];
    /**
     * Gets the delimiter row of the table.
     *
     * @returns The delimiter row; `undefined` if there is not delimiter row.
     */
    getDelimiterRow(): TableRow | undefined;
    /**
     * Gets a cell at the specified index.
     *
     * @param rowIndex - Row index of the cell.
     * @param columnIndex - Column index of the cell.
     * @returns The cell at the specified index; `undefined` if not found.
     */
    getCellAt(rowIndex: number, columnIndex: number): TableCell | undefined;
    /**
     * Gets the cell at the focus.
     *
     * @param focus - Focus object.
     * @returns The cell at the focus; `undefined` if not found.
     */
    getFocusedCell(focus: Focus): TableCell | undefined;
    /**
     * Converts the table to an array of text representations of the rows.
     *
     * @returns An array of text representations of the rows.
     */
    toLines(): string[];
    /**
     * Sets a cell in the table to a new value, returning a copy of the table
     * with the modified value.
     *
     * If an invalid index is provided, the table will be unchanged.
     */
    setCellAt(rowIndex: number, columnIndex: number, value: string): Table;
    /**
     * Computes a focus from a point in the text editor.
     *
     * @param pos - A point in the text editor.
     * @param rowOffset - The row index where the table starts in the text editor.
     * @returns A focus object that corresponds to the specified point;
     * `undefined` if the row index is out of bounds.
     */
    focusOfPosition(pos: Point, rowOffset: number): Focus | undefined;
    /**
     * Computes a position in the text editor from a focus.
     *
     * @param focus - A focus object.
     * @param rowOffset - The row index where the table starts in the text editor.
     * @returns A position in the text editor that corresponds to the focus;
     * `undefined` if the focused row  is out of the table.
     */
    positionOfFocus(focus: Focus, rowOffset: number): Point | undefined;
    /**
     * Computes a selection range from a focus.
     *
     * @param focus - A focus object.
     * @param rowOffset - The row index where the table starts in the text editor.
     * @returns A range to be selected that corresponds to the focus;
     * `undefined` if the focus does not specify any cell or the specified cell is empty.
     */
    selectionRangeOfFocus(focus: Focus, rowOffset: number): Range | undefined;
    /**
     * Evaluate the formula, applying the results to this table and returning the
     * changes as a new table.
     */
    applyFormulas(formulaLines: string[]): Result<Table, Error>;
}
