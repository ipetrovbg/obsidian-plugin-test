"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveColumn = exports.deleteColumn = exports.insertColumn = exports.moveRow = exports.deleteRow = exports.insertRow = exports.alterAlignment = exports.formatTable = exports.FormatType = exports._weakFormatTable = exports._formatTable = exports._padText = exports._alignText = exports._computeTextWidth = exports.completeTable = exports._extendArray = exports._delimiterText = void 0;
const alignment_1 = require("./alignment");
const table_1 = require("./table");
const table_cell_1 = require("./table-cell");
const table_row_1 = require("./table-row");
const meaw_1 = require("meaw");
/**
 * Creates a delimiter text.
 *
 * @private
 * @param width - Width of the horizontal bar of delimiter.
 * @throws {Error} Unknown alignment.
 */
const _delimiterText = (alignment, width) => {
    const bar = '-'.repeat(width);
    switch (alignment) {
        case alignment_1.Alignment.NONE:
            return ` ${bar} `;
        case alignment_1.Alignment.LEFT:
            return `:${bar} `;
        case alignment_1.Alignment.RIGHT:
            return ` ${bar}:`;
        case alignment_1.Alignment.CENTER:
            return `:${bar}:`;
        default:
            throw new Error('Unknown alignment: ' + alignment);
    }
};
exports._delimiterText = _delimiterText;
/**
 * Extends array size.
 *
 * @private
 * @param callback - Callback function to fill newly created cells.
 * @returns Extended array.
 */
const _extendArray = (arr, size, callback) => {
    const extended = arr.slice();
    for (let i = arr.length; i < size; i++) {
        extended.push(callback(i, arr));
    }
    return extended;
};
exports._extendArray = _extendArray;
/**
 * Completes a table by adding missing delimiter and cells.
 * After completion, all rows in the table have the same width.
 *
 * @private
 *
 * @throws {Error} Empty table.
 */
const completeTable = (table, options) => {
    const tableHeight = table.getHeight();
    const tableWidth = table.getWidth();
    if (tableHeight === 0) {
        throw new Error('Empty table');
    }
    const rows = table.getRows();
    const newRows = [];
    // header
    const headerRow = rows[0];
    const headerCells = headerRow.getCells();
    newRows.push(new table_row_1.TableRow(exports._extendArray(headerCells, tableWidth, (j) => new table_cell_1.TableCell(j === headerCells.length ? headerRow.marginRight : '')), headerRow.marginLeft, headerCells.length < tableWidth ? '' : headerRow.marginRight));
    // delimiter
    const delimiterRow = table.getDelimiterRow();
    if (delimiterRow !== undefined) {
        const delimiterCells = delimiterRow.getCells();
        newRows.push(new table_row_1.TableRow(exports._extendArray(delimiterCells, tableWidth, (j) => new table_cell_1.TableCell(exports._delimiterText(alignment_1.Alignment.NONE, j === delimiterCells.length
            ? Math.max(options.minDelimiterWidth, delimiterRow.marginRight.length - 2)
            : options.minDelimiterWidth))), delimiterRow.marginLeft, delimiterCells.length < tableWidth ? '' : delimiterRow.marginRight));
    }
    else {
        newRows.push(new table_row_1.TableRow(exports._extendArray([], tableWidth, () => new table_cell_1.TableCell(exports._delimiterText(alignment_1.Alignment.NONE, options.minDelimiterWidth))), '', ''));
    }
    // body
    for (let i = delimiterRow !== undefined ? 2 : 1; i < tableHeight; i++) {
        const row = rows[i];
        const cells = row.getCells();
        newRows.push(new table_row_1.TableRow(exports._extendArray(cells, tableWidth, (j) => new table_cell_1.TableCell(j === cells.length ? row.marginRight : '')), row.marginLeft, cells.length < tableWidth ? '' : row.marginRight));
    }
    return {
        table: new table_1.Table(newRows),
        delimiterInserted: delimiterRow === undefined,
    };
};
exports.completeTable = completeTable;
/**
 * Calculates the width of a text based on characters' EAW properties.
 *
 * @private
 *
 * @returns Calculated width of the text.
 */
const _computeTextWidth = (text, options) => {
    const normalized = options.normalize ? text.normalize('NFC') : text;
    let w = 0;
    for (const char of normalized) {
        if (options.wideChars.has(char)) {
            w += 2;
            continue;
        }
        if (options.narrowChars.has(char)) {
            w += 1;
            continue;
        }
        switch (meaw_1.getEAW(char)) {
            case 'F':
            case 'W':
                w += 2;
                break;
            case 'A':
                w += options.ambiguousAsWide ? 2 : 1;
                break;
            default:
                w += 1;
        }
    }
    return w;
};
exports._computeTextWidth = _computeTextWidth;
/**
 * Returns a aligned cell content.
 *
 * @throws {Error} Unknown alignment.
 * @throws {Error} Unexpected default alignment.
 */
const _alignText = (text, width, alignment, options) => {
    const space = width - exports._computeTextWidth(text, options);
    if (space < 0) {
        return text;
    }
    switch (alignment) {
        case alignment_1.Alignment.NONE:
            throw new Error('Unexpected default alignment');
        case alignment_1.Alignment.LEFT:
            return text + ' '.repeat(space);
        case alignment_1.Alignment.RIGHT:
            return ' '.repeat(space) + text;
        case alignment_1.Alignment.CENTER:
            return (' '.repeat(Math.floor(space / 2)) +
                text +
                ' '.repeat(Math.ceil(space / 2)));
        default:
            throw new Error('Unknown alignment: ' + alignment);
    }
};
exports._alignText = _alignText;
/**
 * Just adds one space paddings to both sides of a text.
 *
 * @private
 */
const _padText = (text) => ` ${text} `;
exports._padText = _padText;
/**
 * Formats a table.
 *
 * @private
 */
const _formatTable = (table, options) => {
    const tableHeight = table.getHeight();
    const tableWidth = table.getWidth();
    if (tableHeight === 0) {
        return {
            table,
            marginLeft: '',
        };
    }
    const marginLeft = table.getRows()[0].marginLeft;
    if (tableWidth === 0) {
        const rows = new Array(tableHeight).fill(new table_row_1.TableRow([], marginLeft, ''));
        return {
            table: new table_1.Table(rows),
            marginLeft,
        };
    }
    // compute column widths
    const delimiterRow = table.getDelimiterRow();
    const columnWidths = new Array(tableWidth).fill(0);
    if (delimiterRow !== undefined) {
        const delimiterRowWidth = delimiterRow.getWidth();
        for (let j = 0; j < delimiterRowWidth; j++) {
            columnWidths[j] = options.minDelimiterWidth;
        }
    }
    for (let i = 0; i < tableHeight; i++) {
        if (delimiterRow !== undefined && i === 1) {
            continue;
        }
        const row = table.getRows()[i];
        const rowWidth = row.getWidth();
        for (let j = 0; j < rowWidth; j++) {
            columnWidths[j] = Math.max(columnWidths[j], exports._computeTextWidth(row.getCellAt(j).content, options.textWidthOptions));
        }
    }
    // get column alignments
    const alignments = delimiterRow !== undefined
        ? exports._extendArray(delimiterRow.getCells().map((cell) => cell.getAlignment()), tableWidth, 
        // Safe conversion because DefaultAlignment is a subset of Alignment
        () => options.defaultAlignment)
        : new Array(tableWidth).fill(options.defaultAlignment);
    // format
    const rows = [];
    // header
    const headerRow = table.getRows()[0];
    rows.push(new table_row_1.TableRow(headerRow
        .getCells()
        .map((cell, j) => new table_cell_1.TableCell(exports._padText(exports._alignText(cell.content, columnWidths[j], options.headerAlignment === alignment_1.HeaderAlignment.FOLLOW
        ? alignments[j] === alignment_1.Alignment.NONE
            ? options.defaultAlignment
            : alignments[j]
        : options.headerAlignment, options.textWidthOptions)))), marginLeft, ''));
    // delimiter
    if (delimiterRow !== undefined) {
        rows.push(new table_row_1.TableRow(delimiterRow
            .getCells()
            .map((cell, j) => new table_cell_1.TableCell(exports._delimiterText(alignments[j], columnWidths[j]))), marginLeft, ''));
    }
    // body
    for (let i = delimiterRow !== undefined ? 2 : 1; i < tableHeight; i++) {
        const row = table.getRows()[i];
        rows.push(new table_row_1.TableRow(row
            .getCells()
            .map((cell, j) => new table_cell_1.TableCell(exports._padText(exports._alignText(cell.content, columnWidths[j], alignments[j] === alignment_1.Alignment.NONE
            ? options.defaultAlignment
            : alignments[j], options.textWidthOptions)))), marginLeft, ''));
    }
    return {
        table: new table_1.Table(rows),
        marginLeft,
    };
};
exports._formatTable = _formatTable;
/**
 * Formats a table weakly.
 * Rows are formatted independently to each other, cell contents are just trimmed and not aligned.
 * This is useful when using a non-monospaced font or dealing with wide tables.
 *
 * @private
 */
const _weakFormatTable = (table, options) => {
    const tableHeight = table.getHeight();
    const tableWidth = table.getWidth();
    if (tableHeight === 0) {
        return {
            table,
            marginLeft: '',
        };
    }
    const marginLeft = table.getRows()[0].marginLeft;
    if (tableWidth === 0) {
        const rows = new Array(tableHeight).fill(new table_row_1.TableRow([], marginLeft, ''));
        return {
            table: new table_1.Table(rows),
            marginLeft,
        };
    }
    const delimiterRow = table.getDelimiterRow();
    // format
    const rows = [];
    // header
    const headerRow = table.getRows()[0];
    rows.push(new table_row_1.TableRow(headerRow.getCells().map((cell) => new table_cell_1.TableCell(exports._padText(cell.content))), marginLeft, ''));
    // delimiter
    if (delimiterRow !== undefined) {
        rows.push(new table_row_1.TableRow(delimiterRow
            .getCells()
            .map((cell) => new table_cell_1.TableCell(exports._delimiterText(cell.getAlignment(), options.minDelimiterWidth))), marginLeft, ''));
    }
    // body
    for (let i = delimiterRow !== undefined ? 2 : 1; i < tableHeight; i++) {
        const row = table.getRows()[i];
        rows.push(new table_row_1.TableRow(row.getCells().map((cell) => new table_cell_1.TableCell(exports._padText(cell.content))), marginLeft, ''));
    }
    return {
        table: new table_1.Table(rows),
        marginLeft,
    };
};
exports._weakFormatTable = _weakFormatTable;
/**
 * Represents table format type.
 *
 * - `FormatType.NORMAL` - Formats table normally.
 * - `FormatType.WEAK` - Formats table weakly, rows are formatted independently to each other, cell
 *   contents are just trimmed and not aligned.
 */
var FormatType;
(function (FormatType) {
    FormatType["NORMAL"] = "normal";
    FormatType["WEAK"] = "weak";
})(FormatType = exports.FormatType || (exports.FormatType = {}));
/**
 * Formats a table.
 *
 * @private
 *
 * @throws {Error} Unknown format type.
 */
const formatTable = (table, options) => {
    switch (options.formatType) {
        case FormatType.NORMAL:
            return exports._formatTable(table, options);
        case FormatType.WEAK:
            return exports._weakFormatTable(table, options);
        default:
            throw new Error('Unknown format type: ' + options.formatType);
    }
};
exports.formatTable = formatTable;
/**
 * Alters a column's alignment of a table.
 *
 * @private
 * @param table - A completed non-empty table.
 * @param columnIndex - An index of the column.
 * @param alignment - A new alignment of the column.
 * @param options - An object containing options for completion.
 * @returns {Table} An altered table object.
 * If the column index is out of range, returns the original table.
 */
const alterAlignment = (table, columnIndex, alignment, options) => {
    if (table.getHeight() < 1) {
        return table;
    }
    const delimiterRow = table.getRows()[1];
    if (columnIndex < 0 || delimiterRow.getWidth() - 1 < columnIndex) {
        return table;
    }
    const delimiterCells = delimiterRow.getCells();
    delimiterCells[columnIndex] = new table_cell_1.TableCell(exports._delimiterText(alignment, options.minDelimiterWidth));
    const rows = table.getRows();
    rows[1] = new table_row_1.TableRow(delimiterCells, delimiterRow.marginLeft, delimiterRow.marginRight);
    return new table_1.Table(rows);
};
exports.alterAlignment = alterAlignment;
/**
 * Inserts a row to a table.
 * The row is always inserted after the header and the delimiter rows, even if the index specifies
 * the header or the delimiter.
 *
 * @private
 * @param table - A completed non-empty table.
 * @param rowIndex - An row index at which a new row will be inserted.
 * @param row - A table row to be inserted.
 * @returns An altered table obejct.
 */
const insertRow = (table, rowIndex, row) => {
    const rows = table.getRows();
    rows.splice(Math.max(rowIndex, 2), 0, row);
    return new table_1.Table(rows);
};
exports.insertRow = insertRow;
/**
 * Deletes a row in a table.
 * If the index specifies the header row, the cells are emptied but the row will not be removed.
 * If the index specifies the delimiter row, it does nothing.
 *
 * @private
 * @param table - A completed non-empty table.
 * @param rowIndex - An index of the row to be deleted.
 * @returns An altered table obejct.
 */
const deleteRow = (table, rowIndex) => {
    if (rowIndex === 1) {
        return table;
    }
    const rows = table.getRows();
    if (rowIndex === 0) {
        const headerRow = rows[0];
        rows[0] = new table_row_1.TableRow(new Array(headerRow.getWidth()).fill(new table_cell_1.TableCell('')), headerRow.marginLeft, headerRow.marginRight);
    }
    else {
        rows.splice(rowIndex, 1);
    }
    return new table_1.Table(rows);
};
exports.deleteRow = deleteRow;
/**
 * Moves a row at the index to the specified destination.
 *
 * @private
 * @param table - A completed non-empty table.
 * @param rowIndex - Index of the row to be moved.
 * @param destIndex - Index of the destination.
 * @returns An altered table object.
 */
const moveRow = (table, rowIndex, destIndex) => {
    if (rowIndex <= 1 || destIndex <= 1 || rowIndex === destIndex) {
        return table;
    }
    const rows = table.getRows();
    const row = rows[rowIndex];
    rows.splice(rowIndex, 1);
    rows.splice(destIndex, 0, row);
    return new table_1.Table(rows);
};
exports.moveRow = moveRow;
/**
 * Inserts a column to a table.
 *
 * @private
 * @param table - A completed non-empty table.
 * @param columnIndex - An column index at which the new column will be inserted.
 * @param column - An array of cells.
 * @param options - An object containing options for completion.
 * @returns An altered table obejct.
 */
const insertColumn = (table, columnIndex, column, options) => {
    const rows = table.getRows();
    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const cells = rows[i].getCells();
        const cell = i === 1
            ? new table_cell_1.TableCell(exports._delimiterText(alignment_1.Alignment.NONE, options.minDelimiterWidth))
            : column[i > 1 ? i - 1 : i];
        cells.splice(columnIndex, 0, cell);
        rows[i] = new table_row_1.TableRow(cells, row.marginLeft, row.marginRight);
    }
    return new table_1.Table(rows);
};
exports.insertColumn = insertColumn;
/**
 * Deletes a column in a table.
 * If there will be no columns after the deletion, the cells are emptied but the column will not be
 * removed.
 *
 * @private
 * @param table - A completed non-empty table.
 * @param columnIndex - An index of the column to be deleted.
 * @param options - An object containing options for completion.
 * @returns An altered table object.
 */
const deleteColumn = (table, columnIndex, options) => {
    const rows = table.getRows();
    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        let cells = row.getCells();
        if (cells.length <= 1) {
            cells = [
                new table_cell_1.TableCell(i === 1
                    ? exports._delimiterText(alignment_1.Alignment.NONE, options.minDelimiterWidth)
                    : ''),
            ];
        }
        else {
            cells.splice(columnIndex, 1);
        }
        rows[i] = new table_row_1.TableRow(cells, row.marginLeft, row.marginRight);
    }
    return new table_1.Table(rows);
};
exports.deleteColumn = deleteColumn;
/**
 * Moves a column at the index to the specified destination.
 *
 * @private
 * @param table - A completed non-empty table.
 * @param columnIndex - Index of the column to be moved.
 * @param destIndex - Index of the destination.
 * @returns An altered table object.
 */
const moveColumn = (table, columnIndex, destIndex) => {
    if (columnIndex === destIndex) {
        return table;
    }
    const rows = table.getRows();
    for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const cells = row.getCells();
        const cell = cells[columnIndex];
        cells.splice(columnIndex, 1);
        cells.splice(destIndex, 0, cell);
        rows[i] = new table_row_1.TableRow(cells, row.marginLeft, row.marginRight);
    }
    return new table_1.Table(rows);
};
exports.moveColumn = moveColumn;
